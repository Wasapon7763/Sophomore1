将棋の駒の飛車は，上下方向，左右方向に升目があいている限りどこへでも移動できる。特に，空いているその先に敵の駒があれば，その位置に進んでその駒を取ることができる。さらに，飛車は，成ると竜となり，左右斜め前および左右斜め後の４つの升目にある敵の駒も取ることができるようになる。将棋の駒に取って取ることのできる位置にある（敵の）駒を当たりの駒という。

正整数 n について n×n の升目をもつ盤を考え，その上に n 個の竜を，互いに当たりにならないように配置することを考え，可能な配置の総数を出力するプログラムを作れ。

入力は，正整数 n だけを並べた１行からなる。

出力は，可能な配置の総数だけを１行として書き出せ。



入力例１

4

出力例１

2

実際，つぎの２通りの配置だけが可能である。

・竜・・　　　　・・竜・

・・・竜　　　　竜・・・

竜・・・　　　　・・・竜

・・竜・　　　　・竜・・



解説
縦にも横にも，どこまでも“当たり”となるというのが竜の特性であるから，どの行，どの列にも１個の竜しか置くことができない。したがって，たとえば，各行に順に１個の竜をおいていくことにしてみる。

それまでに置いた竜がどの列に置かれているかを記録しておいて，それらの列を除いた残りの列に竜を置くことを試みればいいことになる。つまり，第 i 行についての試みを行うことを try( i ) と書くことにすると，つぎのようになる。

try( i ) ::
　　すべての列 j について
　　　　 j 列にまだ竜が置かれてないなら
             そして一つ左の行に当たりの竜が置かれていないなら
　　　　　　　(i ,j ) に竜をおく
　　　　　　　try(i +1); 
　　　　　　　(i ,j ) の竜を除く　/* バックトラック */
　　呼出し元へ戻る
各行で試行（竜をおくこと）を行って次の行での試行を（再帰呼出しによって）行う。ある段階で試行のしようがなくなると上の段階に戻る。したがって，再帰呼び出しから戻ってきたら，試行で置いた竜を取り除いて別の試行を行う。これで試行が行き詰まったときの後戻り（バックトラック）が実現できていることになる。ただし，このままの形ではすべての段階で試行がうまくいったとき，さらに再帰呼出しをしてしまう。そこでi が升目の最大番号を超えていたら，それはすなわち，そこまでに置いてきた竜がすべての行に（互いに当たらないように）置けたことになるので，やはり再帰を終えるようにすればよい。

以上のことから，結局，つぎのように仕上げればいいことになる。

try( i ) ⇔
　　i が升目の最大行番号を超えていたら
　　　　/* すでに置いてきた竜の配置が解の一つ */
　　　　呼出し元へ戻る
　　すべての行 j について
　　　　 j 行にまだ竜が置かれてないなら
　　　　そして一つ左の行に当たりの竜が置かれていないなら
　　　　　　　(i ,j ) に竜をおく
　　　　　　　try(i +1); 
　　　　　　　(i ,j ) の竜を除く　/* バックトラック */
　　呼出し元へ戻る
このようにすると再帰呼出しの仕組みを利用して，すべて可能な配置を探してくることができることになる。その方針をまとめて置くとつぎのようになる。

何かの試行を何段階行い，それらすべてに成功したら解がえられるとき，次の段階に進むことを再帰呼出しで実現する。
やるべきすべての段階を終えたところまで来たら，その時解が得られている。得られた解を記録するなりして，上の段階に戻る。
各段階では，試行を施した上で再帰呼出しして次の段階に進みその再帰呼出しから戻ってきたらその施した後を消す，ということをその段階で可能なすべての試行について行い，その段階で試行の余地がなくなれば上の段階に戻る。
途中の下線を施した作業によって，後戻り（バックトラック）を成就していることに注意する。
